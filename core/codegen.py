"""Code generation utilities for creating API/UI code from metadata.

This module provides tools to pre-generate Python code from ModelRegistry
and OperationRegistry metadata. Generated code is cached and only regenerated
when models/operations change.

Usage:
    python -m core.codegen compile
    # Generates: .run_cache/generated_api.py, .run_cache/generated_ui_config.ts
"""

from __future__ import annotations

import hashlib
import json
import sys
from pathlib import Path
from textwrap import dedent
from typing import Any

from .config_manager import ConfigManager
from .graph_generator import MermaidGraphGenerator
from .registries import ModelRegistry, OperationRegistry


class CodeGenerator:
    """Base class for code generators."""

    def __init__(self, output_dir: Path = Path(".run_cache")):
        """Initialize generator with output directory."""
        self.output_dir = output_dir
        self.output_dir.mkdir(exist_ok=True)

    def get_metadata_hash(self) -> str:
        """Get hash of current registry state to detect changes."""
        models_data = [
            {
                "name": m.name,
                "searchable": m.searchable_fields,
                "sortable": m.sortable_fields,
                "ui": m.ui_hints,
            }
            for m in ModelRegistry.list_all()
        ]

        ops_data = [
            {
                "name": op.name,
                "category": op.category,
                "inputs": op.input_schema.__name__,
                "outputs": op.output_schema.__name__,
            }
            for op in OperationRegistry.list_all()
        ]

        combined = json.dumps({"models": models_data, "ops": ops_data}, sort_keys=True)
        return hashlib.sha256(combined.encode()).hexdigest()[:12]

    def needs_regeneration(self, output_file: Path) -> bool:
        """Check if output file needs regeneration."""
        if not output_file.exists():
            return True

        # Check if hash has changed
        hash_file = output_file.with_suffix(".hash")
        if not hash_file.exists():
            return True

        current_hash = self.get_metadata_hash()
        stored_hash = hash_file.read_text().strip()

        return current_hash != stored_hash

    def save_hash(self, output_file: Path) -> None:
        """Save current metadata hash."""
        hash_file = output_file.with_suffix(".hash")
        hash_file.write_text(self.get_metadata_hash())


class FastAPIGenerator(CodeGenerator):
    """Generate FastAPI routes from ModelRegistry."""

    def generate(self) -> Path:
        """Generate FastAPI routes file."""
        output_file = self.output_dir / "generated_api.py"

        if not self.needs_regeneration(output_file):
            print(f"‚úì {output_file} is up to date (hash match)")
            return output_file

        print(f"‚Üí Generating {output_file}...")

        # Also generate entrypoint script
        self._generate_entrypoint()

        # Add parent directory to path so imports work
        code_parts = [
            '"""Auto-generated API routes from ModelRegistry.',
            "",
            "‚ö†Ô∏è  DO NOT EDIT MANUALLY - Changes will be overwritten!",
            "    Generated by: python -m core.codegen compile",
            '"""',
            "",
            "import sys",
            "from pathlib import Path",
            "sys.path.insert(0, str(Path(__file__).parent.parent))",
            "",
            "from fastapi import APIRouter, HTTPException, Query",
            "from typing import Optional",
            "",
            "from core.registries import ModelRegistry, OperationRegistry",
            "",
        ]

        # Collect and add all operation schema imports at the top
        operation_imports = set()
        for op in OperationRegistry.list_all():
            input_module = op.input_schema.__module__
            input_class = op.input_schema.__name__
            output_class = op.output_schema.__name__
            operation_imports.add(f"from {input_module} import {input_class}, {output_class}")

        if operation_imports:
            code_parts.append("# Operation schema imports")
            for imp in sorted(operation_imports):
                code_parts.append(imp)
            code_parts.append("")

        # Generate router for each model
        for model_info in ModelRegistry.list_all():
            code_parts.append(self._generate_model_router(model_info))
            code_parts.append("")

        # Define operations router FIRST (before endpoints that use it)
        code_parts.append("\n# Operation Endpoints\n")
        code_parts.append(
            'operations_router = APIRouter(prefix="/operations", tags=["operations"])'
        )
        code_parts.append("")

        # Generate operation endpoints (these use operations_router)
        for op in OperationRegistry.list_all():
            code_parts.append(self._generate_operation_endpoint(op))
            code_parts.append("")

        # Generate main router
        code_parts.append(self._generate_main_router())

        code = "\n".join(code_parts)
        output_file.write_text(code)
        self.save_hash(output_file)

        print(f"‚úì Generated {len(code.splitlines())} lines of API code")
        return output_file

    def _generate_model_router(self, model_info: Any) -> str:
        """Generate CRUD router for a single model."""
        model_name = model_info.name
        model_lower = model_name.lower()
        doc_class = model_info.document_cls.__name__
        module = model_info.document_cls.__module__

        searchable = model_info.searchable_fields
        sortable = model_info.sortable_fields

        return f'''
# {model_name} CRUD Router
# Generated from @datamodel(name="{model_name}")

{model_lower}_router = APIRouter(prefix="/{model_lower}", tags={model_info.tags})


@{model_lower}_router.get("/", summary="List {model_name}s")
async def list_{model_lower}s(
    search: Optional[str] = Query(None, description="Search in: {', '.join(searchable)}"),
    sort_by: Optional[str] = Query(None, description="Sort by: {', '.join(sortable)}"),
    limit: int = Query(10, ge=1, le=100),
    skip: int = Query(0, ge=0),
):
    """List {model_name}s with search and sort.

    Searchable fields: {', '.join(searchable)}
    Sortable fields: {', '.join(sortable)}
    """
    from {module} import {doc_class}

    query = {{}}

    # Search across searchable fields
    if search and {searchable}:
        query["$or"] = [
            {{field: {{"$regex": search, "$options": "i"}}}}
            for field in {searchable}
        ]

    # Apply sorting
    sort_field = sort_by if sort_by in {sortable} else "{sortable[0] if sortable else 'created_at'}"

    items = await {doc_class}.find(query).sort(sort_field).skip(skip).limit(limit).to_list()
    count = await {doc_class}.find(query).count()

    return {{
        "items": items,
        "count": count,
        "skip": skip,
        "limit": limit,
    }}


@{model_lower}_router.get("/{{item_id}}", summary="Get {model_name}")
async def get_{model_lower}(item_id: str):
    """Get a single {model_name} by ID."""
    from {module} import {doc_class}

    item = await {doc_class}.get(item_id)
    if not item:
        raise HTTPException(status_code=404, detail="{model_name} not found")
    return item


@{model_lower}_router.post("/", summary="Create {model_name}")
async def create_{model_lower}(item: dict):
    """Create a new {model_name}."""
    from {module} import {doc_class}

    new_item = {doc_class}(**item)
    await new_item.insert()
    return new_item


@{model_lower}_router.put("/{{item_id}}", summary="Update {model_name}")
async def update_{model_lower}(item_id: str, updates: dict):
    """Update a {model_name}."""
    from {module} import {doc_class}

    item = await {doc_class}.get(item_id)
    if not item:
        raise HTTPException(status_code=404, detail="{model_name} not found")

    # Update fields from dict
    for key, value in updates.items():
        if hasattr(item, key):
            setattr(item, key, value)

    await item.save()
    return item


@{model_lower}_router.delete("/{{item_id}}", summary="Delete {model_name}")
async def delete_{model_lower}(item_id: str):
    """Delete a {model_name}."""
    from {module} import {doc_class}

    item = await {doc_class}.get(item_id)
    if not item:
        raise HTTPException(status_code=404, detail="{model_name} not found")

    await item.delete()
    return {{"success": True}}
'''

    def _generate_operation_endpoint(self, op: Any) -> str:
        """Generate endpoint for a single operation."""
        input_class = op.input_schema.__name__
        output_class = op.output_schema.__name__

        return f'''
@operations_router.post("/{op.name}", summary="{op.description}")
async def {op.name}_endpoint(input_data: {input_class}) -> {output_class}:
    """
    {op.description}

    Category: {op.category}
    Tags: {', '.join(op.tags)}
    Models: {', '.join(op.models_in + op.models_out)}
    """
    # Get operation function from registry
    op_meta = OperationRegistry.get("{op.name}")
    result = await op_meta.function(input_data)

    return result
'''

    def _generate_main_router(self) -> str:
        """Generate main router that includes all sub-routers + FastAPI app."""
        router_names = [f"{m.name.lower()}_router" for m in ModelRegistry.list_all()]

        includes = "\n    ".join([f"api_router.include_router({name})" for name in router_names])

        return f'''
# Main API Router and FastAPI App

from fastapi import FastAPI
from fastapi.responses import JSONResponse
import os
from motor.motor_asyncio import AsyncIOMotorClient
from beanie import init_beanie

api_router = APIRouter(prefix="/api/v1")

# Include all model routers
def setup_routes():
    """Setup all routes. Call this from main FastAPI app."""
    {includes}
    api_router.include_router(operations_router)
    return api_router

# Create FastAPI app with all routes
app = FastAPI(
    title="JobHunter Core API",
    description="Auto-generated API from ModelRegistry",
    version="0.1.0",
)

# Setup routes
setup_routes()

# Include main API router
app.include_router(api_router)

# Health check endpoint
@app.get("/health")
async def health():
    """Health check endpoint."""
    return JSONResponse({{"status": "ok", "service": "jobhunter-api"}})

# Initialize database on startup
@app.on_event("startup")
async def startup():
    """Initialize MongoDB and Beanie on startup."""
    try:
        mongo_url = os.getenv("MONGODB_URL", "mongodb://mongodb:27017")
        db_name = os.getenv("MONGODB_DATABASE", "jobhunter")

        # Create Motor async client
        client = AsyncIOMotorClient(mongo_url)

        # Import all models for Beanie initialization
        import sys
        import importlib
        models = []
        for registry_model in ModelRegistry.list_all():
            models.append(registry_model.document_cls)

        # Initialize Beanie with all models
        await init_beanie(
            database=client[db_name],
            document_models=models,
        )
        print(f"‚úì Database initialized: {{db_name}}")
    except Exception as e:
        print(f"‚úó Failed to initialize database: {{e}}")
'''

    def _generate_entrypoint(self) -> Path:
        """Generate entrypoint.py that uvicorn can run directly."""
        entrypoint_file = self.output_dir / "entrypoint.py"

        entrypoint_code = '''#!/usr/bin/env python3
"""Generated entrypoint for uvicorn.

‚ö†Ô∏è  DO NOT EDIT MANUALLY - Changes will be overwritten!
    Generated by: python -m core.codegen compile

This script properly sets up the Python path before importing the FastAPI app,
allowing uvicorn to find the run_cache module in Docker containers.
"""

import sys
from pathlib import Path

# Add parent directory to Python path so 'core' module can be imported
app_root = Path(__file__).parent.parent
sys.path.insert(0, str(app_root))

# Now import the FastAPI app after path is set up
from run_cache.generated_api import app  # noqa: E402

if __name__ == "__main__":
    import uvicorn

    uvicorn.run(
        app,
        host="0.0.0.0",
        port=8000,
        log_level="info",
    )
'''

        entrypoint_file.write_text(entrypoint_code)
        entrypoint_file.chmod(0o755)
        print(f"  ‚úì Generated {entrypoint_file}")
        return entrypoint_file


class TypeScriptUIConfigGenerator(CodeGenerator):
    """Generate TypeScript UI configuration from ModelRegistry."""

    def generate(self) -> Path:
        """Generate TypeScript UI config file."""
        output_file = self.output_dir / "generated_ui_config.ts"

        if not self.needs_regeneration(output_file):
            print(f"‚úì {output_file} is up to date (hash match)")
            return output_file

        print(f"‚Üí Generating {output_file}...")

        code_parts = [
            "/**",
            " * Auto-generated UI configuration from ModelRegistry",
            " *",
            " * ‚ö†Ô∏è  DO NOT EDIT MANUALLY - Changes will be overwritten!",
            " *     Generated by: python -m core.codegen compile",
            " */",
            "",
            "export interface ModelUIConfig {",
            "  name: string;",
            "  icon: string;",
            "  primaryField: string;",
            "  secondaryField?: string;",
            "  listFields: string[];",
            "  searchableFields: string[];",
            "  sortableFields: string[];",
            "  detailSections: Array<{",
            "    name: string;",
            "    fields: string[];",
            "    collapsible?: boolean;",
            "    collapsed?: boolean;",
            "  }>;",
            "}",
            "",
            "export const MODEL_CONFIGS: Record<string, ModelUIConfig> = {",
        ]

        # Generate config for each model
        for model_info in ModelRegistry.list_all():
            config = {
                "name": model_info.name,
                "icon": model_info.ui_hints.get("icon", "üìÑ"),
                "primaryField": model_info.ui_hints.get("primary_field", "id"),
                "secondaryField": model_info.ui_hints.get("secondary_field"),
                "listFields": model_info.ui_hints.get("list_fields", []),
                "searchableFields": model_info.searchable_fields,
                "sortableFields": model_info.sortable_fields,
                "detailSections": model_info.ui_hints.get("detail_sections", []),
            }

            config_json = json.dumps(config, indent=2)
            code_parts.append(f"  {model_info.name}: {config_json},")

        code_parts.append("};")
        code_parts.append("")
        code_parts.append("// Auto-generated resource definitions for Refine.dev")
        code_parts.append("export const RESOURCES = Object.keys(MODEL_CONFIGS).map(name => ({")
        code_parts.append("  name: name.toLowerCase(),  // Lowercase to match API endpoints")
        code_parts.append("  list: `/${name.toLowerCase()}s`,")
        code_parts.append("  show: `/${name.toLowerCase()}s/:id`,")
        code_parts.append("  create: `/${name.toLowerCase()}s/new`,")
        code_parts.append("  edit: `/${name.toLowerCase()}s/:id/edit`,")
        code_parts.append("  meta: MODEL_CONFIGS[name],")
        code_parts.append("}));")

        code = "\n".join(code_parts)
        output_file.write_text(code)
        self.save_hash(output_file)

        print(f"‚úì Generated {len(code.splitlines())} lines of TypeScript config")
        return output_file


class RefinePageGenerator(CodeGenerator):
    """Generate Refine.dev page components from ModelRegistry.

    NOTE: This class is used internally by CopyAndGenerateFrontend.
    All generated files go to .run_cache/generated_frontend/
    """

    def __init__(self, output_dir: Path = Path(".run_cache/generated_frontend/src")):
        """Initialize with generated frontend directory."""
        super().__init__(output_dir)

    def _generate_list_page(self, model_info: Any, pages_dir: Path) -> Path:
        """Generate List page component."""
        model_name = model_info.name
        model_lower = model_name.lower()
        list_fields = model_info.ui_hints.get("list_fields", [])

        # Generate table columns from list_fields
        columns = "\n      ".join(
            [
                f'<Table.Column dataIndex="{field}" title="{field.replace("_", " ").title()}" key="{field}" />'
                for field in list_fields
            ]
        )

        # Build code without f-string to avoid colon conflicts with TypeScript
        code = f"""/**
 * Auto-generated List page for {model_name}
 *
 * ‚ö†Ô∏è  DO NOT EDIT MANUALLY - Changes will be overwritten!
 *     Generated by: python -m core.codegen compile
 */

import {{ List, useTable, EditButton, ShowButton, DeleteButton }} from "@refinedev/antd";
import {{ Table, Space }} from "antd";

export const {model_name}List = () => {{
  const {{ tableProps }} = useTable({{
    resource: "{model_lower}",
  }});

  return (
    <List>
      <Table {{...tableProps}} rowKey="id">
        {columns}
        <Table.Column
          title="Actions"
          dataIndex="actions"
          render={{(_: any, record: any) => (
            <Space>
              <EditButton hideText size="small" recordItemId={{record.id}} />
              <ShowButton hideText size="small" recordItemId={{record.id}} />
              <DeleteButton hideText size="small" recordItemId={{record.id}} />
            </Space>
          )}}
        />
      </Table>
    </List>
  );
}};
"""
        output_file = pages_dir / "list.tsx"
        output_file.write_text(code)
        print(f"  ‚úì Generated {output_file}")
        return output_file

    def _generate_show_page(self, model_info: Any, pages_dir: Path) -> Path:
        """Generate Show page component."""
        model_name = model_info.name
        detail_sections = model_info.ui_hints.get("detail_sections", [])

        # Generate field displays grouped by sections
        sections_code = []
        for section in detail_sections:
            fields = "\n          ".join(
                [
                    f'<TextField title="{field.replace("_", " ").title()}" value={{record?.{field}}} />'
                    for field in section["fields"]
                ]
            )
            sections_code.append(
                f"""
        <div style={{{{ marginBottom: 24 }}}}>
          <h3>{section["name"]}</h3>
          {fields}
        </div>"""
            )

        sections_html = "".join(sections_code)

        code = f"""/**
 * Auto-generated Show page for {model_name}
 *
 * ‚ö†Ô∏è  DO NOT EDIT MANUALLY - Changes will be overwritten!
 *     Generated by: python -m core.codegen compile
 */

import {{ Show, TextField }} from "@refinedev/antd";
import {{ useShow }} from "@refinedev/core";

export const {model_name}Show = () => {{
  const {{ queryResult }} = useShow();
  const {{ data, isLoading }} = queryResult;
  const record = data?.data;

  return (
    <Show isLoading={{isLoading}}>
      {sections_html}
    </Show>
  );
}};
"""
        output_file = pages_dir / "show.tsx"
        output_file.write_text(code)
        print(f"  ‚úì Generated {output_file}")
        return output_file

    def _generate_create_page(self, model_info: Any, pages_dir: Path) -> Path:
        """Generate Create page component."""
        model_name = model_info.name
        list_fields = model_info.ui_hints.get("list_fields", [])

        # Generate form items
        form_items = "\n        ".join(
            [
                f'<Form.Item label="{field.replace("_", " ").title()}" name="{field}">\n          <Input />\n        </Form.Item>'
                for field in list_fields
                if field not in ["id", "created_at", "updated_at"]
            ]
        )

        code = f"""/**
 * Auto-generated Create page for {model_name}
 *
 * ‚ö†Ô∏è  DO NOT EDIT MANUALLY - Changes will be overwritten!
 *     Generated by: python -m core.codegen compile
 */

import {{ Create }} from "@refinedev/antd";
import {{ Form, Input }} from "antd";

export const {model_name}Create = () => {{
  return (
    <Create saveButtonProps={{{{ htmlType: "submit" }}}}>
      <Form layout="vertical">
        {form_items}
      </Form>
    </Create>
  );
}};
"""
        output_file = pages_dir / "create.tsx"
        output_file.write_text(code)
        print(f"  ‚úì Generated {output_file}")
        return output_file

    def _generate_edit_page(self, model_info: Any, pages_dir: Path) -> Path:
        """Generate Edit page component."""
        model_name = model_info.name
        list_fields = model_info.ui_hints.get("list_fields", [])

        # Generate form items
        form_items = "\n        ".join(
            [
                f'<Form.Item label="{field.replace("_", " ").title()}" name="{field}">\n          <Input />\n        </Form.Item>'
                for field in list_fields
                if field not in ["id", "created_at", "updated_at"]
            ]
        )

        code = f"""/**
 * Auto-generated Edit page for {model_name}
 *
 * ‚ö†Ô∏è  DO NOT EDIT MANUALLY - Changes will be overwritten!
 *     Generated by: python -m core.codegen compile
 */

import {{ Edit }} from "@refinedev/antd";
import {{ Form, Input }} from "antd";
import {{ useForm }} from "@refinedev/antd";

export const {model_name}Edit = () => {{
  const {{ formProps, saveButtonProps }} = useForm();

  return (
    <Edit saveButtonProps={{saveButtonProps}}>
      <Form {{...formProps}} layout="vertical">
        {form_items}
      </Form>
    </Edit>
  );
}};
"""
        output_file = pages_dir / "edit.tsx"
        output_file.write_text(code)
        print(f"  ‚úì Generated {output_file}")
        return output_file

    def _generate_index_file(self, model_info: Any, pages_dir: Path) -> Path:
        """Generate index.ts to export all page components."""
        model_name = model_info.name

        code = f"""/**
 * Auto-generated index for {model_name} pages
 */

export {{ {model_name}List }} from "./list";
export {{ {model_name}Show }} from "./show";
export {{ {model_name}Create }} from "./create";
export {{ {model_name}Edit }} from "./edit";
"""
        output_file = pages_dir / "index.ts"
        output_file.write_text(code)
        print(f"  ‚úì Generated {output_file}")
        return output_file


class CopyAndGenerateFrontend(CodeGenerator):
    """Copy frontend template and generate complete frontend."""

    def __init__(self, output_dir: Path = Path(".run_cache/generated_frontend")):
        """Initialize with generated frontend directory."""
        super().__init__(output_dir)
        # template_dir is at core/frontend_template (sibling of core/core/)
        self.template_dir = Path(__file__).parent.parent / "frontend_template"

    def generate(self) -> Path:
        """Copy template and generate complete frontend."""
        import shutil

        print("\n‚Üí Generating complete frontend...")

        # Step 1: Copy template (remove old if exists)
        if self.output_dir.exists():
            shutil.rmtree(self.output_dir)

        shutil.copytree(self.template_dir, self.output_dir)
        print(f"  ‚úì Copied template to {self.output_dir}")

        # Step 2: Generate App.tsx from template
        self._generate_app_tsx()

        # Step 3: Copy UI config
        self._copy_ui_config()

        # Step 4: Generate all pages
        generated_pages = []
        for model_info in ModelRegistry.list_all():
            pages = self._generate_model_pages(model_info)
            generated_pages.extend(pages)

        print(f"  ‚úì Generated {len(generated_pages)} page files")

        # Step 5: Create instructions file
        self._create_instructions()

        return self.output_dir

    def _generate_app_tsx(self):
        """Generate App.tsx from template with model imports and routes."""
        template_file = self.output_dir / "src" / "App.tsx.template"
        output_file = self.output_dir / "src" / "App.tsx"

        if not template_file.exists():
            print(f"  ‚ö†Ô∏è  Warning: Template file {template_file} not found")
            return

        template_content = template_file.read_text()

        # Generate imports for all models
        imports = []
        routes = []

        for model_info in ModelRegistry.list_all():
            model_name = model_info.name
            model_lower = model_name.lower()

            # Add import
            imports.append(
                f'import {{ {model_name}List, {model_name}Show, {model_name}Create, {model_name}Edit }} from "./pages/{model_lower}";'
            )

            # Add routes
            routes.extend(
                [
                    f"            {{/* {model_name} Routes */}}",
                    "            <Route",
                    "              element={",
                    "                <ThemedLayoutV2>",
                    f"                  <{model_name}List />",
                    "                </ThemedLayoutV2>",
                    "              }",
                    f'              path="/{model_lower}s"',
                    "            />",
                    "            <Route",
                    "              element={",
                    "                <ThemedLayoutV2>",
                    f"                  <{model_name}Show />",
                    "                </ThemedLayoutV2>",
                    "              }",
                    f'              path="/{model_lower}s/:id"',
                    "            />",
                    "            <Route",
                    "              element={",
                    "                <ThemedLayoutV2>",
                    f"                  <{model_name}Create />",
                    "                </ThemedLayoutV2>",
                    "              }",
                    f'              path="/{model_lower}s/create"',
                    "            />",
                    "            <Route",
                    "              element={",
                    "                <ThemedLayoutV2>",
                    f"                  <{model_name}Edit />",
                    "                </ThemedLayoutV2>",
                    "              }",
                    f'              path="/{model_lower}s/edit/:id"',
                    "            />",
                    "",
                ]
            )

        # Replace placeholders
        output_content = template_content.replace("{%IMPORTS%}", "\n".join(imports))
        output_content = output_content.replace("{%ROUTES%}", "\n".join(routes))

        output_file.write_text(output_content)
        template_file.unlink()  # Remove template file

        print(f"  ‚úì Generated {output_file}")

    def _copy_ui_config(self):
        """Copy generated UI config to frontend."""
        source = Path(".run_cache/generated_ui_config.ts")
        dest = self.output_dir / "src" / "config" / "generated.ts"
        dest.parent.mkdir(parents=True, exist_ok=True)

        if source.exists():
            dest.write_text(source.read_text())
            print(f"  ‚úì Copied UI config to {dest}")
        else:
            print(f"  ‚ö†Ô∏è  Warning: {source} not found")

    def _generate_model_pages(self, model_info: Any) -> list[Path]:
        """Generate all pages for a model."""
        model_name = model_info.name
        model_lower = model_name.lower()

        pages_dir = self.output_dir / "src" / "pages" / model_lower
        pages_dir.mkdir(parents=True, exist_ok=True)

        generated = []

        # Use existing page generation logic
        page_gen = RefinePageGenerator(self.output_dir / "src")
        generated.append(page_gen._generate_list_page(model_info, pages_dir))
        generated.append(page_gen._generate_show_page(model_info, pages_dir))
        generated.append(page_gen._generate_create_page(model_info, pages_dir))
        generated.append(page_gen._generate_edit_page(model_info, pages_dir))
        generated.append(page_gen._generate_index_file(model_info, pages_dir))

        return generated

    def _create_instructions(self):
        """Create instructions file for using generated frontend."""
        instructions = """# Generated Frontend

This directory contains a **fully generated frontend** from your @datamodel decorators.

## ‚ö†Ô∏è DO NOT EDIT FILES HERE DIRECTLY!

All files in this directory are auto-generated. Changes will be overwritten on next `make codegen`.

## How to Use

### 1. Install Dependencies (First Time Only)

```bash
cd .run_cache/generated_frontend
npm install
```

### 2. Run Development Server

```bash
npm run dev
```

The UI will be available at: http://localhost:3000

### 3. Build for Production

```bash
npm run build
```

Output will be in `dist/` directory.

## Customization

To customize the frontend:

1. **Edit the template:** `core/frontend_template/src/App.tsx.template`
2. **Regenerate:** Run `make codegen`
3. **Your changes will appear here**

## Generated Content

This directory contains:
- ‚úÖ All npm dependencies installed
- ‚úÖ TypeScript configuration
- ‚úÖ Vite build configuration
- ‚úÖ React app with Refine.dev
- ‚úÖ Auto-generated pages for all models
- ‚úÖ Auto-generated routes
- ‚úÖ Auto-generated config

## Models Included

"""
        for model in ModelRegistry.list_all():
            instructions += f"- {model.name} ({model.description or 'No description'})\n"

        instructions += f"\n**Total:** {len(ModelRegistry.list_all())} models\n"

        (self.output_dir / "README.md").write_text(instructions)
        print("  ‚úì Created README.md with instructions")


def _discover_and_import_items(project_dir: Path) -> None:
    """Discover and import models/operations from project directories.

    Uses dynamic imports to find Python files with @datamodel/@operation decorators.
    Importing the files causes decorators to run and register the items.

    Args:
        project_dir: Path to project directory
    """
    import importlib.util

    # Load config to get model/operation directories
    config_path = project_dir / ".jobhunter.yml"
    if config_path.exists():
        try:
            config_mgr = ConfigManager(config_path)
            config = config_mgr.load()
            models_dirs = config.get("models_dirs", ["models"])
            operations_dirs = config.get("operations_dirs", ["operations"])
        except Exception:
            models_dirs = ["models"]
            operations_dirs = ["operations"]
    else:
        models_dirs = ["models"]
        operations_dirs = ["operations"]

    # Add project directory to path for imports
    project_dir_str = str(project_dir)
    if project_dir_str not in sys.path:
        sys.path.insert(0, project_dir_str)

    # Import all model files
    for model_dir in models_dirs:
        model_path = project_dir / model_dir
        if not model_path.exists():
            continue

        for py_file in sorted(model_path.glob("*.py")):
            if py_file.name == "__init__.py":
                continue

            try:
                # Dynamically import the file
                spec = importlib.util.spec_from_file_location(f"models.{py_file.stem}", py_file)
                if spec and spec.loader:
                    module = importlib.util.module_from_spec(spec)
                    spec.loader.exec_module(module)
            except Exception as e:
                print(f"  ‚ö†Ô∏è  Could not import {py_file}: {e}")

    # Import all operation files
    for ops_dir in operations_dirs:
        ops_path = project_dir / ops_dir
        if not ops_path.exists():
            continue

        for py_file in sorted(ops_path.glob("*.py")):
            if py_file.name == "__init__.py":
                continue

            try:
                # Dynamically import the file
                spec = importlib.util.spec_from_file_location(f"operations.{py_file.stem}", py_file)
                if spec and spec.loader:
                    module = importlib.util.module_from_spec(spec)
                    spec.loader.exec_module(module)
            except Exception as e:
                print(f"  ‚ö†Ô∏è  Could not import {py_file}: {e}")


def compile_all(project_dir: Path | None = None):
    """Compile all code generators from models and operations.

    This function automatically discovers and imports all @datamodel and @operation
    decorated items from the project's models/ and operations/ directories.
    Decorators automatically register them in ModelRegistry and OperationRegistry.

    Args:
        project_dir: Project directory for output (defaults to cwd, can be set via CONFIG_FILE env var)

    Example:
        # Simple - just call it, it will discover everything:
        from core import compile_all
        compile_all()
    """
    import os

    # Get project directory from parameter, environment, or current directory
    if project_dir is None:
        config_file = os.environ.get("CONFIG_FILE", ".")
        config_path = Path(config_file).absolute()
        # If CONFIG_FILE points to a file, use its parent directory
        project_dir = config_path.parent if config_path.is_file() else config_path
    else:
        project_dir = Path(project_dir).absolute()

    # Change to project directory so relative paths work
    os.chdir(project_dir)

    print("\n=== Running Code Generators ===\n")
    print(f"üìÇ Project directory: {project_dir}\n")

    # Discover and import models and operations from project directories
    print("üîç Discovering models and operations...")
    _discover_and_import_items(project_dir)
    print("   ‚úÖ Discovery complete\n")

    # Read from registries (now populated by imports)
    models = ModelRegistry.list_all()
    operations = OperationRegistry.list_all()

    print(f"üì¶ Registered: {len(models)} models, {len(operations)} operations\n")

    # Run generators
    api_gen = FastAPIGenerator()
    api_file = api_gen.generate()

    ui_gen = TypeScriptUIConfigGenerator()
    ui_file = ui_gen.generate()

    # Generate complete frontend (copy template + generate pages)
    frontend_gen = CopyAndGenerateFrontend()
    frontend_dir = frontend_gen.generate()

    # Read project configuration to get project name
    config_path = project_dir / ".jobhunter.yml"
    project_name = "cli"  # Default fallback
    if config_path.exists():
        try:
            config_mgr = ConfigManager(config_path)
            config = config_mgr.load()
            project_name = config.get("project_name", "cli")
        except Exception:
            pass  # Use default if config read fails

    # Generate CLI executable
    print("\n‚Üí Generating CLI...")
    cli_file = _generate_cli(project_name)

    # Generate architecture graphs
    print("\n‚Üí Generating architecture diagrams...")
    try:
        docs_dir = Path.cwd() / "docs"
        graph_gen = MermaidGraphGenerator(docs_dir)
        models = ModelRegistry.list_all()
        operations = OperationRegistry.list_all()
        graph_gen.generate_all(models, operations)
        graph_gen.create_architecture_index(len(models), len(operations))
        print(f"  ‚úì Graphs generated in {docs_dir}/")
    except Exception as e:
        print(f"  ‚ö†Ô∏è  Could not generate graphs: {e}")

    print("\n=== Code Generation Complete ===")
    print("\nGenerated files:")
    print(f"  - {api_file}")
    print(f"  - {ui_file}")
    print(f"  - {frontend_dir}/ (complete frontend)")
    print(f"  - {cli_file} (CLI executable)")
    print("  - docs/ (architecture diagrams)")
    print("\nTo use:")
    print("  API: from .run_cache.generated_api import setup_routes")
    print(f"  Frontend: cd {frontend_dir} && npm install && npm run dev")
    print(f"  CLI: ./{cli_file} --help")


def _generate_cli(project_name: str = "cli"):
    """Generate CLI executable from registered operations.

    Args:
        project_name: Name to use for the CLI executable

    Returns:
        Path to the generated CLI file (relative path as string)
    """
    output_dir = Path("cli")
    output_dir.mkdir(parents=True, exist_ok=True)

    cli_file = output_dir / project_name

    # Collect operation metadata
    operations = []
    for op in OperationRegistry.list_all():
        operations.append(
            {
                "name": op.name,
                "description": op.description,
                "category": op.category,
            }
        )

    # Generate CLI script
    cli_script = dedent(
        f'''\
#!/usr/bin/env python3
"""Generated CLI - Auto-generated at compile time.

‚ö†Ô∏è  DO NOT EDIT MANUALLY - Changes will be overwritten!
    Regenerate with: make compile

This CLI is generated from @operation decorated functions.
"""

import sys
import json

# Operations registered at compile time
OPERATIONS = {json.dumps(operations, indent=4)}

def list_operations():
    """List all registered operations."""
    if not OPERATIONS:
        print("\\n‚ùå No operations registered\\n")
        return
    print("\\nüìã Registered Operations:\\n")
    for op in OPERATIONS:
        print(f"  {{op['name']:<30}} - {{op['description']}}")
    print(f"\\nüìä Total: {{len(OPERATIONS)}} operations\\n")

def show_operation(name: str):
    """Show details for a specific operation."""
    for op in OPERATIONS:
        if op['name'] == name:
            print(f"\\nüìù Operation: {{op['name']}}")
            print(f"   Description: {{op['description']}}")
            print(f"   Category: {{op['category']}}")
            print()
            return
    print(f"\\n‚ùå Operation '{{name}}' not found\\n")

def main():
    """Main CLI entry point."""
    if len(sys.argv) < 2 or sys.argv[1] in ('--help', '-h', 'help'):
        print("\\nüöÄ Generated CLI\\n")
        list_operations()
        return

    command = sys.argv[1]

    if command == "list":
        list_operations()
    elif command == "inspect" and len(sys.argv) > 2:
        show_operation(sys.argv[2])
    else:
        print(f"\\n‚ùå Unknown command: {{command}}")
        print("\\nAvailable commands: list, inspect <name>\\n")

if __name__ == "__main__":
    main()
'''
    )

    cli_file.write_text(cli_script)
    cli_file.chmod(0o755)

    print(f"‚úì Generated CLI: {cli_file}")

    # Return relative path for display
    return f"cli/{project_name}"


if __name__ == "__main__":
    # Generate code from registered models and operations
    compile_all()
