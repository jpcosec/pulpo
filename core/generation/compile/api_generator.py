"""FastAPI code generator.

Generates FastAPI routes and application from ModelRegistry and OperationRegistry.
Output: run_cache/generated_api.py
"""

from __future__ import annotations

from pathlib import Path
from typing import Any

from ..base import CodeGenerator
from ...analysis.registries import ModelRegistry, OperationRegistry


class FastAPIGenerator(CodeGenerator):
    """Generate FastAPI routes from ModelRegistry."""

    def __init__(self, output_dir: Path = Path(".run_cache"), project_name: str = "pulpo-app"):
        """Initialize generator with output directory and project name."""
        super().__init__(output_dir)
        self.project_name = project_name

    def generate(self) -> Path:
        """Generate FastAPI routes file."""
        output_file = self.output_dir / "generated_api.py"

        if not self.needs_regeneration(output_file):
            print(f"✓ {output_file} is up to date (hash match)")
            return output_file

        print(f"→ Generating {output_file}...")

        # Also generate entrypoint script
        self._generate_entrypoint()

        # Add parent directory to path so imports work
        code_parts = [
            '"""Auto-generated API routes from ModelRegistry.',
            "",
            "⚠️  DO NOT EDIT MANUALLY - Changes will be overwritten!",
            "    Generated by: python -m core.codegen compile",
            '"""',
            "",
            "import sys",
            "from pathlib import Path",
            "sys.path.insert(0, str(Path(__file__).parent.parent))",
            "",
            "from fastapi import APIRouter, HTTPException, Query",
            "from typing import Optional",
            "",
            "from core.analysis.registries import ModelRegistry, OperationRegistry",
            "",
        ]

        # Collect and add all operation schema imports at the top
        operation_imports = set()
        for op in OperationRegistry.list_all():
            input_module = op.input_schema.__module__
            input_class = op.input_schema.__name__
            output_class = op.output_schema.__name__
            operation_imports.add(f"from {input_module} import {input_class}, {output_class}")

        if operation_imports:
            code_parts.append("# Operation schema imports")
            for imp in sorted(operation_imports):
                code_parts.append(imp)
            code_parts.append("")

        # Generate router for each model
        for model_info in ModelRegistry.list_all():
            code_parts.append(self._generate_model_router(model_info))
            code_parts.append("")

        # Define operations router FIRST (before endpoints that use it)
        code_parts.append("\n# Operation Endpoints\n")
        code_parts.append(
            'operations_router = APIRouter(prefix="/operations", tags=["operations"])'
        )
        code_parts.append("")

        # Generate operation endpoints (these use operations_router)
        for op in OperationRegistry.list_all():
            code_parts.append(self._generate_operation_endpoint(op))
            code_parts.append("")

        # Generate main router
        code_parts.append(self._generate_main_router())

        code = "\n".join(code_parts)
        output_file.write_text(code)
        self.save_hash(output_file)

        print(f"✓ Generated {len(code.splitlines())} lines of API code")
        return output_file

    def _generate_model_router(self, model_info: Any) -> str:
        """Generate CRUD router for a single model."""
        model_name = model_info.name
        model_lower = model_name.lower()
        doc_class = model_info.document_cls.__name__
        module = model_info.document_cls.__module__

        searchable = model_info.searchable_fields
        sortable = model_info.sortable_fields

        return f'''
# {model_name} CRUD Router
# Generated from @datamodel(name="{model_name}")

{model_lower}_router = APIRouter(prefix="/{model_lower}", tags={model_info.tags})


@{model_lower}_router.get("/", summary="List {model_name}s")
async def list_{model_lower}s(
    search: Optional[str] = Query(None, description="Search in: {', '.join(searchable)}"),
    sort_by: Optional[str] = Query(None, description="Sort by: {', '.join(sortable)}"),
    limit: int = Query(10, ge=1, le=100),
    skip: int = Query(0, ge=0),
):
    """List {model_name}s with search and sort.

    Searchable fields: {', '.join(searchable)}
    Sortable fields: {', '.join(sortable)}
    """
    from {module} import {doc_class}

    query = {{}}

    # Search across searchable fields
    if search and {searchable}:
        query["$or"] = [
            {{field: {{"$regex": search, "$options": "i"}}}}
            for field in {searchable}
        ]

    # Apply sorting
    sort_field = sort_by if sort_by in {sortable} else "{sortable[0] if sortable else 'created_at'}"

    items = await {doc_class}.find(query).sort(sort_field).skip(skip).limit(limit).to_list()
    count = await {doc_class}.find(query).count()

    return {{
        "items": items,
        "count": count,
        "skip": skip,
        "limit": limit,
    }}


@{model_lower}_router.get("/{{item_id}}", summary="Get {model_name}")
async def get_{model_lower}(item_id: str):
    """Get a single {model_name} by ID."""
    from {module} import {doc_class}

    item = await {doc_class}.get(item_id)
    if not item:
        raise HTTPException(status_code=404, detail="{model_name} not found")
    return item


@{model_lower}_router.post("/", summary="Create {model_name}")
async def create_{model_lower}(item: dict):
    """Create a new {model_name}."""
    from {module} import {doc_class}

    new_item = {doc_class}(**item)
    await new_item.insert()
    return new_item


@{model_lower}_router.put("/{{item_id}}", summary="Update {model_name}")
async def update_{model_lower}(item_id: str, updates: dict):
    """Update a {model_name}."""
    from {module} import {doc_class}

    item = await {doc_class}.get(item_id)
    if not item:
        raise HTTPException(status_code=404, detail="{model_name} not found")

    # Update fields from dict
    for key, value in updates.items():
        if hasattr(item, key):
            setattr(item, key, value)

    await item.save()
    return item


@{model_lower}_router.delete("/{{item_id}}", summary="Delete {model_name}")
async def delete_{model_lower}(item_id: str):
    """Delete a {model_name}."""
    from {module} import {doc_class}

    item = await {doc_class}.get(item_id)
    if not item:
        raise HTTPException(status_code=404, detail="{model_name} not found")

    await item.delete()
    return {{"success": True}}
'''

    def _generate_operation_endpoint(self, op: Any) -> str:
        """Generate endpoint for a single operation."""
        input_class = op.input_schema.__name__
        output_class = op.output_schema.__name__

        return f'''
@operations_router.post("/{op.name}", summary="{op.description}")
async def {op.name}_endpoint(input_data: {input_class}) -> {output_class}:
    """
    {op.description}

    Category: {op.category}
    Tags: {', '.join(op.tags)}
    Models: {', '.join(op.models_in + op.models_out)}
    """
    # Get operation function from registry
    op_meta = OperationRegistry.get("{op.name}")
    result = await op_meta.function(input_data)

    return result
'''

    def _generate_main_router(self) -> str:
        """Generate main router that includes all sub-routers + FastAPI app."""
        router_names = [f"{m.name.lower()}_router" for m in ModelRegistry.list_all()]

        includes = "\n    ".join([f"api_router.include_router({name})" for name in router_names])

        return f'''
# Main API Router and FastAPI App

from fastapi import FastAPI
from fastapi.responses import JSONResponse
import os
from motor.motor_asyncio import AsyncIOMotorClient
from beanie import init_beanie

api_router = APIRouter(prefix="/api/v1")

# Include all model routers
def setup_routes():
    """Setup all routes. Call this from main FastAPI app."""
    {includes}
    api_router.include_router(operations_router)
    return api_router

# Create FastAPI app with all routes
app = FastAPI(
    title="{self.project_name.title()} API",
    description="Auto-generated API from ModelRegistry",
    version="0.1.0",
)

# Setup routes
setup_routes()

# Include main API router
app.include_router(api_router)

# Health check endpoint
@app.get("/health")
async def health():
    """Health check endpoint."""
    return JSONResponse({{"status": "ok", "service": "{self.project_name}-api"}})

# Initialize database on startup
@app.on_event("startup")
async def startup():
    """Initialize MongoDB and Beanie on startup."""
    try:
        mongo_url = os.getenv("MONGODB_URL", "mongodb://mongodb:27017")
        db_name = os.getenv("MONGODB_DATABASE", "{self.project_name}")

        # Create Motor async client
        client = AsyncIOMotorClient(mongo_url)

        # Import all models for Beanie initialization
        import sys
        import importlib
        models = []
        for registry_model in ModelRegistry.list_all():
            models.append(registry_model.document_cls)

        # Initialize Beanie with all models
        await init_beanie(
            database=client[db_name],
            document_models=models,
        )
        print(f"✓ Database initialized: {{db_name}}")
    except Exception as e:
        print(f"✗ Failed to initialize database: {{e}}")
'''

    def _generate_entrypoint(self) -> Path:
        """Generate entrypoint.py that uvicorn can run directly."""
        entrypoint_file = self.output_dir / "entrypoint.py"

        entrypoint_code = '''#!/usr/bin/env python3
"""Generated entrypoint for uvicorn.

⚠️  DO NOT EDIT MANUALLY - Changes will be overwritten!
    Generated by: python -m core.codegen compile

This script properly sets up the Python path before importing the FastAPI app,
allowing uvicorn to find the run_cache module in Docker containers.
"""

import sys
from pathlib import Path

# Add parent directory to Python path so 'core' module can be imported
app_root = Path(__file__).parent.parent
sys.path.insert(0, str(app_root))

# Now import the FastAPI app after path is set up
from run_cache.generated_api import app  # noqa: E402

if __name__ == "__main__":
    import uvicorn

    uvicorn.run(
        app,
        host="0.0.0.0",
        port=8000,
        log_level="info",
    )
'''

        entrypoint_file.write_text(entrypoint_code)
        entrypoint_file.chmod(0o755)
        print(f"  ✓ Generated {entrypoint_file}")
        return entrypoint_file


